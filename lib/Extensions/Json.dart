part of './Extensions.dart';

/// extension use for Json map
extension JsonExtension on Json {
  ///Returns a valid [String] which has characters length greater than [1] and not equal to ["null"]
  ///Otherwise [null] will be returned.
  ///Used inside [fromJson]
  String? nullableString(String key) {
    final String? text = this[key] == null ? null : '${this[key]}';
    return text;
  }

  ///Returns a [String] which is not [null]
  String safeString(String key, {dynamic orElse = ''}) {
    return nullableString(key) ?? (orElse ?? '').toString();
  }

  /// This returns any given input as [int].
  /// Usage: some of the [double] formats are causing issues when delivering from the front end.
  /// If the parsed data is [null], the [orElse] data will be used as output.
  /// If no [orElse] value is given, [0] will be returned.
  int safeInt(
      String key, {
        int orElse = 0,
      }) =>
      int.tryParse('${this[key]}') ?? orElse;

  /// Returns [double] if any values are found as valid.
  double? nullableDouble(String key) => double.tryParse('${this[key]}')?.toFixedDigit;

  ///Parses the double values from Json
  double safeDouble(String key, {double? orElse}) {
    final double result = nullableDouble(key) ?? orElse ?? 0;
    return result.toFixedDigit;
  }

  /// Returns [int] if any values are found as valid.
  int? nullableInt(String key) => int.tryParse('${this[key]}');

  ///Parses the value as [bool]
  bool safeBool(String key, {bool orElse = false}) {
    final dynamic _parsedData = this[key];

    ///Parsed data as String, because in sql its stored as [int]
    final String bs = '$_parsedData';

    ///NOSQL database
    if (<bool>[true, false].contains(_parsedData)) {
      return _parsedData == true;

      ///SQL database
    } else if (<String>['0', '1', '0.0', '1.0'].contains(bs)) {
      return bs == '1' || bs == '1.0';
    } else {
      ///Not sure what the data type is so returning [orElse]
      return orElse;
    }
  }

  ///Parses the [createdAt] value as [int]
  ///A common access is applied, because 99% of the models we create will
  int get createdAt => (this['createdAt'] ?? DateTime.now().millisecondsSinceEpoch) as int;

  ///Unique id which was generated by mssql
  int get id => (this['id'] ?? 0) as int;

  ///Last time the data is updated at, If no updated at value found, then created at value will be considered
  int get updatedAt =>
      (this['updatedAt'] ?? createdAt ?? DateTime.now().millisecondsSinceEpoch) as int;

  ///Parses the given Json with the given key and returns if any Json is available
  Json? nullableJson(String key) {
    if (this[key] is Json) {
      return this[key];
    } else if (this[key] is String) {
      return json.decode(this[key]);
    } else {
      return null;
    }
  }

  ///Returns a safe Json
  Json safeJson(String key) => nullableJson(key) ?? <String, dynamic>{};

  ///Generates a List of dynamic from the given key inside the Json
  List<dynamic> safeListOfDynamics(String key, {List<dynamic> orElse = const <dynamic>[]}) {
    final Object? object = this[key];
    if (object is List<dynamic>) {
      return this[key] as List<dynamic>;
    } else if (object is String) {
      // Decode the string into a List<dynamic>
      return json.decode(object);
    } else {
      return orElse;
    }
  }

  ///Returns the List from the given [key]
  List<String> safeListOfStrings(String key, {List<String> orElse = const <String>[]}) {
    return safeListOfDynamics(key, orElse: orElse).toListOfStrings;
  }

  ///Creates TimeOfDay fromTime the given String
  TimeOfDay timeOfDay(String key) {
    final List<String> parts = safeString(key).split(':');
    int hour = 9;
    int minute = 0;
    if (parts.length == 2) {
      hour = Widgets.safeInt(<String, String>{'hour': parts.first}, 'hour');
      minute = Widgets.safeInt(<String,String >{'minute': parts.last}, 'minute');
    }
    return TimeOfDay(hour: hour, minute: minute);
  }

  ///Returns color from the given String
  Color? getColor(dynamic key) {
    final dynamic color = this[key];
    if (color == null) {
      return null;
    }
    int? value;
    if (color is String) {
      value = int.tryParse(color);
    }
    if (color is int) {
      value = color;
    }
    return value == null ? null : Color(value);
  }

  ///Returns the date object from the given Json data
  DateTime safeDateTime(String key, {DateTime? orElse}) {
    return nullableDateTime(key) ?? orElse ?? DateTime.now();
  }

  ///Returns the date object from the given Json data
  ///If the data is not valid, this will return [null]
  DateTime? nullableDateTime(String key) {
    if (this[key] is int) {
      return DateTime.fromMillisecondsSinceEpoch(this[key]);
    } else if (this[key] is String) {
      return DateTime.tryParse('${this[key]}');
    } else if (this[key] is DateTime) {
      return this[key];
    }
    return null;
  }

  /// check if TimeOfDay null
  TimeOfDay? nullableTimeOfDay(String key) {
    if (this[key] == null) {
      return null;
    } else {
      return safeTimeOfDay(key);
    }
  }

  ///Parses TimeOfDay from the given Json
  TimeOfDay safeTimeOfDay(String key) {
    TimeOfDay timeOfDay = const TimeOfDay(hour: 0, minute: 0);
    final String timeString = (this[key] ?? '0:0') as String;
    final List<String> parts = timeString.split(':');

    if (parts.length == 2) {
      final int hour = int.tryParse(parts[0]) ?? 0;
      final int minute = int.tryParse(parts[1]) ?? 0;

      if (hour >= 0 && hour <= 23 && minute >= 0 && minute <= 59) {
        timeOfDay = TimeOfDay(hour: hour, minute: minute);
      }
    }
    return timeOfDay;
  }
}
